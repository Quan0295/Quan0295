#include "ssd1306h.h"
#include "MAX30102.h"
#include "Pulse.h"

#ifndef cbi
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#endif
#ifndef sbi
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
#endif

SSD1306 oled;
MAX30102 sensor;
Pulse pulseIR;
Pulse pulseRed;
MAFilter bpm;

// ================= GPIO =================
#define LED_POWER 23
#define BTN_RESET 25
#define MAXWAVE 72

// ================= HEART ICON =================
static const uint8_t heart_bits[] PROGMEM = {
  0x00,0x00,0x38,0x38,0x7c,0x7c,0xfe,0xfe,0xfe,0xff,
  0xfe,0xff,0xfc,0x7f,0xf8,0x3f,0xf0,0x1f,0xe0,0x0f,
  0xc0,0x07,0x80,0x03,0x00,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00
};

// ================= SPO2 TABLE =================
const uint8_t spo2_table[184] PROGMEM = {
  95,95,95,96,96,96,97,97,97,97,97,98,98,98,98,98,99,99,99,99,
  99,99,99,99,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,
  100,100,100,100,99,99,99,99,99,99,99,99,98,98,98,98,98,98,97,97,
  97,97,96,96,96,96,95,95,95,94,94,94,93,93,93,92,92,92,91,91,
  90,90,89,89,89,88,88,87,87,86,86,85,85,84,84,83,82,82,81,81,
  80,80,79,78,78,77,76,76,75,74,74,73,72,72,71,70,69,69,68,67,
  66,66,65,64,63,62,62,61,60,59,58,57,56,56,55,54,53,52,51,50,
  49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,31,30,29,
  28,27,26,25,23,22,21,20,19,17,16,15,14,12,11,10,9,7,6,5,
  3,2,1
};

// ================= DIGIT =================
void print_digit(int x, int y, long val, char c=' ', uint8_t field=3,const int BIG=2) {
  uint8_t ff = field;
  do {
    char ch = (val!=0) ? val%10+'0' : c;
    oled.drawChar(x+BIG*(ff-1)*6, y, ch, BIG);
    val = val/10;
    --ff;
  } while (ff>0);
}

// ================= WAVEFORM =================
class Waveform {
public:
  Waveform(void) {wavep = 0;}

  void record(int waveval) {
    waveval = waveval/8;
    waveval += 128;
    waveval = waveval<0? 0 : waveval;
    waveform[wavep] = (uint8_t)(waveval>255?255:waveval);
    wavep = (wavep+1) % MAXWAVE;
  }

  void scale() {
    uint8_t maxw = 0, minw = 255;
    for (int i=0;i<MAXWAVE;i++) {
      maxw = waveform[i]>maxw?waveform[i]:maxw;
      minw = waveform[i]<minw?waveform[i]:minw;
    }
    uint8_t scale8 = (maxw-minw)/4 + 1;
    uint8_t index = wavep;
    for (int i=0;i<MAXWAVE;i++) {
      disp_wave[i] = 31-((uint16_t)(waveform[index]-minw)*8)/scale8;
      index = (index + 1) % MAXWAVE;
    }
  }

  void draw(uint8_t X) {
    for (int i=0;i<MAXWAVE;i++) {
      uint8_t y = disp_wave[i];
      oled.drawPixel(X+i, y);
      if (i<MAXWAVE-1) {
        uint8_t ny = disp_wave[i+1];
        if (ny>y) for (uint8_t iy=y+1;iy<ny;iy++) oled.drawPixel(X+i, iy);
        else if (ny<y) for (uint8_t iy=ny+1;iy<y;iy++) oled.drawPixel(X+i, iy);
      }
    }
  }

private:
  uint8_t waveform[MAXWAVE];
  uint8_t disp_wave[MAXWAVE];
  uint8_t wavep = 0;
} wave;

// ================= GLOBAL =================
int beatAvg = 0;
int SPO2 = 0, SPO2f = 0;
bool filter_for_graph = false;
bool draw_Red = false;

uint8_t sleep_counter = 0;
long lastBeat = 0;
long displaytime = 0;

#define MAX_BPM_HISTORY 5
#define MAX_SPO2_HISTORY 10
int bpm_history[MAX_BPM_HISTORY] = {0};
int spo2_history[MAX_SPO2_HISTORY] = {0};
int bpm_index = 0;
int spo2_index = 0;

int averageArray(int *arr, int len) {
  long sum = 0;
  for (int i=0;i<len;i++) sum += arr[i];
  return sum/len;
}

// ================= OLED =================
void draw_oled(int msg) {
  oled.firstPage();
  do {
    switch(msg) {
      case 0: oled.drawStr(10,0,F("Device error"),1); break;
      case 1: oled.drawStr(13,10,F("PLACE"),1); oled.drawStr(10,20,F("FINGER"),1); break;
      case 2:
        print_digit(86,0,beatAvg);
        wave.draw(8);
        print_digit(98,24,SPO2,' ',3,1);
        oled.drawChar(116,24,'%');
        break;
      case 3: oled.drawStr(16,2,F("NHOM 23"),1); break;
      case 4:
        oled.drawStr(2,6,F("THIET BI DO NHIP TIM"),1);
        oled.drawStr(0,18,F("NONG DO OXI TRONG MAU"),1);
        break;
    }
  } while (oled.nextPage());
}

// ================= SETUP =================
void setup() {
  Serial.begin(115200);
  delay(1000);

  pinMode(LED_POWER, OUTPUT);
  digitalWrite(LED_POWER, HIGH);

  pinMode(BTN_RESET, INPUT_PULLUP);

  oled.init();
  oled.fill(0x00);
  draw_oled(3);
  delay(3000);

  if (!sensor.begin()) {
    draw_oled(0);
    while (1);
  }
  sensor.setup();
}

// ================= LOOP =================
void loop() {

  // ===== BUTTON RESET (KHÔNG CHẶN LOOP) =====
  static bool lastBtn = HIGH;
  bool btn = digitalRead(BTN_RESET);

  if (lastBtn == HIGH && btn == LOW) {
    beatAvg = 0; SPO2 = 0; SPO2f = 0;
    bpm_index = 0; spo2_index = 0;
    lastBeat = 0;
    for (int i=0;i<MAX_BPM_HISTORY;i++) bpm_history[i]=0;
    for (int i=0;i<MAX_SPO2_HISTORY;i++) spo2_history[i]=0;
    oled.fill(0x00);
    draw_oled(1);
  }
  lastBtn = btn;

  sensor.check();
  long now = millis();
  if (!sensor.available()) return;

  uint32_t irValue = sensor.getIR();
  uint32_t redValue = sensor.getRed();

  // ===== GIỮ NGUYÊN SERIAL CHO WINFORMS =====
  float Vref = 1.8;
  float V_IR  = (float)irValue / 262143.0 * Vref;
  float V_RED = (float)redValue / 262143.0 * Vref;

  Serial.print(millis());
  Serial.print(",");
  Serial.print(V_IR, 6);
  Serial.print(",");
  Serial.println(V_RED, 6);

  sensor.nextSample();

  if (irValue < 5000) {
    draw_oled(sleep_counter<=50 ? 1 : 4);
    delay(200);
    if (++sleep_counter>100) sleep_counter=0;
    return;
  }
  sleep_counter = 0;

  int16_t IR_signal, Red_signal;
  bool beatIR, beatRed;

  IR_signal = pulseIR.dc_filter(irValue);
  Red_signal = pulseRed.dc_filter(redValue);
  beatIR = pulseIR.isBeat(pulseIR.ma_filter(IR_signal));
  beatRed = pulseRed.isBeat(pulseRed.ma_filter(Red_signal));

  wave.record(draw_Red ? -Red_signal : -IR_signal);

  if (draw_Red ? beatRed : beatIR) {
    long btpm = 60000 / (now - lastBeat);
    if (btpm > 40 && btpm < 180) {
      bpm_history[bpm_index++] = btpm;
      if (bpm_index >= MAX_BPM_HISTORY) bpm_index = 0;
      beatAvg = averageArray(bpm_history, MAX_BPM_HISTORY);
    }
    lastBeat = now;

    long num = (pulseRed.avgAC() * pulseIR.avgDC())/256;
    long den = (pulseRed.avgDC() * pulseIR.avgAC())/256;
    int RX100 = (den>0) ? (num*100)/den : 999;

    if (RX100>=0 && RX100<184) {
      spo2_history[spo2_index++] = pgm_read_byte_near(&spo2_table[RX100]);
      if (spo2_index>=MAX_SPO2_HISTORY) spo2_index=0;
      SPO2 = averageArray(spo2_history, MAX_SPO2_HISTORY);
    }
  }

  if (now - displaytime > 200) {
    displaytime = now;
    wave.scale();
    draw_oled(2);
  }
}

